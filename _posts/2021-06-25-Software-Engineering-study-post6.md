---
title: "소프트웨어 공학 - Chpater 11. 신뢰성 공학"

categories:
  - Software Engineering
tags: 
  - Software Engineering
last_modified_at: 2021-07-03
---

신뢰성 공학에 대한 파트다.

가용성과 신뢰성은 소프트웨어 공학에서 꽤 많이 다뤄지기 때문에 외우기보단 이해하는 것이 필요했다.

기준은 한티 미디어 소프트웨어 공학 제 10판이다.

* 신뢰성 공학 목차
   * 가용성과 신뢰성
   * 신뢰성 요구사항
   * 결함 내성 아키텍처
   * 신뢰성을 위한 프로그래밍
   * 신뢰성 측정

## System Reliability [316p]

* 사회의 많은 측면이 소프트웨어 시스템에 의존
   * 중대한 시스템은 신뢰성 요구사항이 매우 높다

* 결함-오류-고장 (Fault Error Failure) 모델

   * 사람의 오류 또는 실수 (Human Error or Mistake)
      * 시스템 결함이 생기게 하는 사람의 행동
   * 시스템 결함 (System Fault)
      * 시스템 오류로 이어질 수 있는 시스템의 특성
   * 시스템 오류 (System Error)
      * 예기치 못한 시스템 행동으로 이어질 수 있는 시스템의 잘못된 상태
   * 시스템 장애 (System Failure)
      * 사용자가 기대하는 서비스를 시스템이 제공하지 못하는 특정 시점의 사건

* 시스템 결함이 반드시 시스템 오류를 초래하지는 않고, 시스템 오류가 반드시 시스템 장애를 초래하지는 않는다.

* 시스템 결함이 시스템 오류를 반드시 초래하지는 않는 이유 3 가지
   * 프로그램의 모든 코드가 실행되는 것이 아니다.
   * 오류는 일시적이다
   * 시스템이 결함 감지 및 보호 메커니즘을 포함할 수 있다.

## Reliability Achievement [317p]


* 결함,오류,고장의 구분은 시스템의 신뢰성을 향상시키기 위해서 사용될 세가지 보완적인 접근법

* 결함 회피 (Fault Avoidance)
   * 설계 및 프로그래밍 오류를 피하는 소프트웨어 개발 방식으로 시스템에 도입되는 결함을 최소화 함
   * 강한 자료형 언어 사용, 포인터와 같은 오류가 발생하기 쉬운 요소 사용 최소화

* 결함 감지 및 정정 (Fault Detection & Correction)
   * 검증 및 확인 (V&V) 프로세스를 통해 결함을 발견하고 제거함
   * 체계적인 테스팅, 디버깅, 정적 분석

*결함 내성 (Fault Tolerance)
   * 실행 중에 결함이나 시스템의 예기치 못한 행동을 감지하여 시스템 장애가 일어나지 않도록 시스템을 설계
   * 결함 내성 아키텍처


## Availability and Reliability [319p]

* 신뢰성
   * 주어진 환경에서 특정 목적을 위해 지정된 시간 동안 고장 없이 운영될 확률
   * 주어진 기간 동안 시스템이 (정확하게) 서비스를 제공할 확률

* 가용성
   * 주어진 시점에서 시스템이 운영 중이고 요청된 서비스를 제공할 확률
   * 참고 : 어떤 시점에 시스템이 작동 (서비스를 제공)할 확률

* 신뢰성은 시스템의 환경에 따라 달라짐
   * 사용되는 장소, 사용하는 방법

* **고장 없는 운영 (Failure - free Operation)**
   * 고장의 기술적 정의는 시스템 명세를 준수하지 않는 것
      * 엔지니어들은 시스템이 사용되는 분야의 전문가가 아니기 때문에 사용자가 기대하는  동작을 구현하지 않을 수 있다 이 소프트웨어는 명세서에 있는 대로 동작하지만 사용자에게는 여전히 장애가 발생한 것이다
      * 시스템 개발자를 제외하고 아무도 소프트웨어 명세서를 읽지 않는다. 따라서 사용자가 예상하는 소프트웨어의 동작은 명세서와 완전히 다른 방식일 수 있다.
   * 고장은 객관적 정의가 어려우며 시스템 사용자에 의해 판단됨

* **가용성과 신뢰성**
   * 가용성은 장애 횟수뿐만 아니라 수리 시간의 영향을 받음
      * 수리시간이 적게 걸리는 시스템이 가용성이 더 좋은 시스템이다.
   * 시스템에 따라 가용성 또는 신뢰성이 더 중요함

Tip)
신뢰성과 가용성은 밀접하게 관련되어 있지만, 때로는 어떤 하나가 다른 하나보다 더 중요하다. 

만약 사용자가 어떤 시스템으로부터 지속적인 서비스를 기대하는 경우 그 시스템은 고가용성 요구사항을 가진다. 

그것은 수요가 있을 때 반드시 사용가능해야 한다. 

그러나 만약 시스템이 사용자 데이터 손실 없이 장애로부터 빠르게 복구될 수 있다면 이러한 장애는 시스템 사용자들에게  큰 영향을 미치지 않을 것이다.

## System Reliability Requirements [322p]

* 신뢰성 요구사항
   * 명세는 불완전하고 부정확할 수 있다
   * 소프트웨어 장애 뿐만 아니라 하드웨어 고장과 운영자의 오류도 고려해야 한다

* 확실성 요구사항의 유형

   * 기능적 요구사항
      * 시스템에 포함되어야 하는 점검 및 복구 기능
      * 시스템 장애 및 외부 공격에 대한 보호 기능

   * 비기능적 요구사항
      * 신뢰성과 가용성

   * 소프트웨어 시스템은 고립된 것이 아니라 인간, 사회, 조직의 목적이 있는 광범위한 시스템, 사람, 프로세스, 규정 등 비기술적 요소를 포함한다. 

## System Metrics [322p]

* 신뢰성 척도
   * 시스템이 주어진 운영 환경에서 시스템 장애가 일어날 확률

* 온 디맨드 고장 확률 (POFOD : Probability of Failure On Demand)
   * 시스템 서비스에 대한 요구가 시스템 장애를 일으킬 확률

* 고장 발생 비율 (ROCOF : Rate of Occurrence of Failure)
   * 어떤 시간 간격 (또는 시스템 실행 횟수) 동안 발생할 수 있는 시스템 장애 횟수
   * 고장 간 평균 시간 (MTTF : Mean Time To Failure) 의 역수
   * 이 척도는 특정 시간 간격(예를 들어, 1시간) 또는 시스템 실행 횟수에서 발생할 수 있는 시스템 장애의 확률수를 나타낸다. 위의 예에서, ROCOF는1/1000이다. ROCOF의 역수는 신뢰성 척도로 가끔 사용되는 고장 평균시간(MTTF)이다. MTTF는 시스템 장애 간의 시간 단위 평균이다. 한시간당 두번의 고장이 있을 때의 ROCOF는 고장 평균 시간이 30분임을 의미하다.

* 가용성 척도 (AVAIL : availability)
   * 서비스 요구가 있을 때 시스템이 운영 중일 확률
   * 가용성 = 운영시간 / 전체시간
   * AVAIL은 서비스에 대한 요구가 있을 때 시스템이 가동중일 확률이다. 따라서0.9999의 가용성은 평균적으로 시스템이 운영 시간의 99.99%동안 사용가능함을 의미한다. 

* POFOD (요구에 대한 고장 확률)
   * 요구에 대한 실패가 심각한 시스템 장애로 이어지는 경우
   * 요구의 빈도와 관계 없이 적용됨
   * EX) 화학 반응기를 감시하고 과열되면 정지시키는 방호 시스템

* ROCOF (고장 발생 비율)
   * 요구의 빈도가 정기적일 때 사용
   * 요구의 빈도가 간헐적일 때보다 빈도가 정기적일 때 사용한다.
   * 하루에 10번 트랜잭션 실패, 1000개 트랜잭션 당 10개 실패

* MTTF
   * 고장 간 시간이 중요한 경우 사용
   * 긴 트랜잭션을 가지는 시스템은 MTTF 가 평균 트랜잭션 수행 시간 보다 길어야 한다

* 비기능적 신뢰성 요구사항은 신뢰성 척도를 사용
## Functional Reliability Requirements [327p]

* 검사 요구사항
   * 부정확하거나 범위를 벗어난 입력을 감지

* 복구 요구사항
   * 시스템과 데이터의 사본 관리
   * 장애 발생 후 시스템을 복원하는 방법

* 중복 요구사항
   * 시스템의 중복 기능을 명시

* 프로세스 요구사항
   * 개발 프로세스에 대한 요구사항

## Fault Tolerance [327~328p]

* 결함 내성
   * 결함은 소프트웨어나 하드웨어에 내재되어 있는 특성이다
   * 실행 중에 소프트웨어나 하드웨어 결함이 발생하고 시스템 상태가 잘못된 경우에도 시스템이 동작을 계속
   * 결함 발생이 시스템 장애로 이어지지 않도록 잘못된 상태를 감지하고 정정함

* 결함 내성을 위한 아키텍처
   * 중복되고 다양한 하드웨어 및 소프트웨어를 포함

* 복제 서버를 이용한 아키텍처
   * 두 대 이상의 서버가 동일한 작업을 수행, 서버 관리 컴포넌트가 있음
   * 복제 서버는 중복성은 제공하지만 일반적으로 다양성은 제공하지 않음
      * 서버 하드웨어는 일반적으로 동일하고, 서버는 소프트웨어의 동일한 버전을 실행한다. 따라서 단일 기계에 국한된 하드웨어 및 소프트웨어 장애를 대처할 수 있으나, 동시에 소프트웨어의 모든 버전에 장애를 일으키는 소프트웨어 설계 문제에는 대처할 수 없다.

* Active Standby 형식
   * Request 가 들어온다면 양쪽 서버에서 다 보내서 A 서버에서도 처리해주고 B 서버에서도 처리해준다. <br/>그리고 둘 다 Response 를 보내면 안 되니까 Active 된 서버에서 Response 를 보내준다.

* 다른 방법 = Primary, Back-Up 형식
   * Request 가 들어왔을 때 양쪽 (Active, Stand-By) 으로 다 신호가 간다. <br/> 둘이 같이 죽을 수 있으니까 Request 가 들어오면 Primary, Back-Up 이라 나눠 Back-Up에는 Request 가 안 가고 Primary 에만 간다. <br/>Primary 는 상태만 Back-Up 에 건넨다.<br/>그러면 Primary 프로세스가 유지하는 어플리케이션의 상태는 넘기지만 Primary 는 Request 를 처리해 Response 를 처리하고 Back-Up 은 어플리케이션에서 중요한 내용을 넘겨받는다. <br/>그래서 만약 Primary 프로세스가 죽으면 Back-Up 프로세스가 이어받아서 Request 를 처리한다.


## Guidelines for Reliability Programming [336~342p]

* 정보의 가시성을 제한
   * 변수와 데이터 구조에 대한 접근을 통제, 추상 데이터 타입 사용

* 모든 입력이 유효한지 검사
   * 범위 검사, 크기 검사, 표현 검사, 타당성 검사

* 모든 예외에 대해 처리기를 제공

* 오류가 발생하기 쉬운 구조의 사용을 최소화
   * 부동 소수점 정밀도에 의존, 동적 기억장소 사용

* 재시작 기능을 제공

* 자동 배열 경계 검사를 사용

* 외부 컴포넌트 호출 시 타임아웃 포함

* 실세계의 값을 나타내는 모든 상수에 이름 부여

* 결함
   * 결함 회피
   * 결함 감지
   * 결함 내성

## Reliability Measurement [342~345p]

* 시스템 신뢰성 측정을 위한 데이터
   * 서비스 요청 횟수에 대한 시스템 장애 횟수 : POFOD
   * 시스템 장애 사이의 시간 간격 또는 트랜잭션 개수 : ROCOF, MTTF
      * 시간 단위는 실제 시간 또는 트랜잭션 개수를 사용
   * 시스템 장애가 발생한 후 수리 또는 재시작에 걸리는 시간 : AVAIL

* 운영 프로파일 (Operational Profile)
   * 시스템의 입력 유형과 해당 입력 유형 발생 확률
   * 시스템이 실제로 사용되는 방식을 반영
   * 기존 시스템을 대체하는 경우에는 사용되는 방식을 알기 쉬움
   * 새롭고 혁신적이 시스템 개발 시는 사용되는 방식을 예측하기 어려움

소프트웨어 시스템의 운영 프로파일은 그것이 실제로 사용되는 방식을 반영한다. 

운영 프로파일은 입력 유형과 그 입력 유형의 발생 확률의 명세로 구성된다.

신뢰성뿐만이 아니라 성능 테스트를 할 때 일반적인 고객들이 사용하는 방법들과 비슷한 방법들을 이야기한다.

(어떤 트랜잭션이 시간마다 몇 개씩 들어오더라, 어떤 종료 액션이 들어오더라)
